# Mon Apr  8 14:07:16 CST 2013

## 对 Keep-Alive

在 response header 中按照如下方式指定

       Connection: Keep-Alive
       Keep-Alive: max=5, timeout=120

要做到这点, 需要在每个链接上做 timeout 管理, 并且对某些请求做合理的配
置(某些请求需要长时间链接)现在的解决方案是当链接处理完了, 就丢掉客户端.

# Tue Apr  9 15:48:19 CST 2013

##  client 端错误信息的处理
现在 client 端的错误可能会在两个地方保留抛出:

* HTTP 请求解析出错
* 后端任务处理时出错

这两种错误都有可能是客户端的原因(包错误), 也可能是服务器的原因(处理错误), 
一旦发生错误, 现有的处理方法都是丢掉该客户端连接(`http_client_free`). 目前这两类错误
并没有统一处理.

对于后端处理出错, 实际上可能是 `4**` 错误, 也有可能是 `5**` 错误, 如果后端和前端同时出
错, 那么就可能有问题.

导致这个问题的原因是后端的出错信息返回是在前面 HTTP 解析的回调中处理的, 所以, 如果后端
出错, 其错误 (如果处理正确, 其也会先返回 `200` 状态)会先报告给客户端, 然后解析完毕, 前端如果
还发现有错误的话, 又会报告一遍, 傻逼了.

之所以将后端处理放到 HTTP 解析的回调中去处理, 是因为有一个 `on_message_complete` 回调,
当 HTTP 解析完毕后, 就会调用该函数, 然后我觉得可以在这里面处理数据了.

正确的办法应该是, 在 `on_message_complete` 函数中, 先判断解析是否正确,
比如 `Content-Length` 是否与实际的 body 长度一致. 当解析完全正确之后, 再处理数据, 这样,
错误的返回顺序就不会颠覆三观了.
