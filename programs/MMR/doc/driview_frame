#-----------------------DRIVIEW C框架基本结构说明-------------------------------#
	模块划分：
	1、套接字缓冲连接池:缓冲套接字连接
	2、主线程（MASTER）	:事件驱动	
					维护套接字缓冲连接池;
					监听连接
					分发连接到RECVER线程
					其他管理任务

	3、接收线程（RECVER）	:事件驱动
					协议解析；
					业务数据封装；
					指派任务给WORKER（工作）线程

	4、业务处理线程（WORKER）:同步
					维护任务列表
					调用业务层处理函数（LUA）
					任务处理结束后通知SENDER（发送）线程

	5、发送线程（SENDER）:	事件驱动
					响应

#-----------------------DRIVIEW 启动过程及LUA加载基本说明-------------------------------#
MMR框架应用加载过程：
	1、应用启动，执行app_init;此时还没有data目录，app_init无效果
	2、执行driview_load.cfg；加载应用/情景；生成data目录
	3、重起应用，虚拟机加载data新生成文件，同时app_init执行有效调用


line_start文件说明:
	local模式位图的生成规则?
	只有local、exact模式生成位图；
	alone的匹配规则?
	
	app_call：应用请求
	app_init：根据data/depot/模式名.lua文件  设置
		设置内容：
	其他app_XX调用：依赖driview_load.lua中设置（生成data目录并根据参数设置该目录下文件）

	app_init
		初始化access日志
		初始化监控
		初始化redis调用
		初始化位图(lua)
		初始化模式位图（C）：只有local模式有实际的初始化动作
		初始化每个模式下的应用：（如：local_insmod）
			输入源：以data/下每个模式文件
			函数："MODEL_NAME"_insmod("应用名/情景名","开启或关闭标志")
			逻辑：
				1、检查是否该应用已经加载
				2、如果cfg.lua文件中“OPEN_LOG_CLASSIFY”标志开启，为该应用/情景生成对应的日志文件
				3、加载该情景模块/应用到虚拟机
				4、获取该情景模块“bind”信息
				5、根据“bind”信息创建关键字（每种模式）
					1、设置位图(lua)   (根据cfg.lua中slots槽位信息设置位图)
					2、根据位图计算出关键字（唯一代表一个绑定规则）
				6、将情景名/关键字对设置到该模式的记录table中
				7、将情景名/开关标志对设置到该模式的记录table中	
				8、将该情景名添加到对应的关键字池（table）中
				9、将该情景的执行函数引用添加到函数池中
				10、卸载该模块
			初始化factory():factory可以用来做简单功能块的测试


	app_call如何判断调用：
		1、数据按规定的格式传入：json格式（包含属性和值）
		2、取请求源数据的所有属性值，设置位图
		3、根据位图计算出关键字，并将关键字取反（后面比较时直接按位&）
		4、以local模式为例子：
			因为local规则为包含了关键字即认为匹配成功
			1、轮流比对local模式的存储池，如果有匹配的，执行对应函数
			（判断local模式是否匹配会不会有问题）
		5、清空位图
